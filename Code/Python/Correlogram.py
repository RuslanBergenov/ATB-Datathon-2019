
import time
start = time.time()



# =============================================================================
# # IMPORT PACKAGES AND FUNCTIONS
# =============================================================================
import pandas as pd
import sqlalchemy

# =============================================================================
# #CREATE THE DATABASE ENGINE
# =============================================================================
con_string = "insert_my_connection_string"
engine = sqlalchemy.engine.create_engine(con_string)

# =============================================================================
# # QUERY AND SAVE TO DATAFRAME
# =============================================================================
# CREATE A COMPOUND PARAMETER
# REMOVE LAST 15 CHARS FROM GEO NAME
df = pd.read_sql_query("""

                      select distinct
-- get geo type based on geo name
case
when geo like '%#[000000000#]%' {escape '#'}  then 'Canada'
when geo like '%#[PR%' {escape '#'}  then 'Province'
when geo like '%#[CAR%' {escape '#'}  then 'CensusAgriculturalRegion'
when geo like '%#[CD%'  {escape '#'}  then 'CensusDivision'
when geo like '%#[CCS%' {escape '#'}   then 'CensusConsolidatedSubdivision'
when geo like 'Northwest Territories%' or geo like 'Yukon%' or geo like 'Nunavut%' then 'Territory'
end as Geo_Type,

-- GEO,

-- remove all characters after ' ['
LEFT(GEO, CHARINDEX(' [', GEO) - 1) as GEO1,
REPLACE(CONCAT(Indicator,'_',IndicatorLevel,'_',[Unit of Measure]), ' ', '') as Parameter,
sum (Value) as SumValue

from [dbo].[censusmat]

where SourceTable in (32100426, 32100432, 32100446 )

group by

(case
when geo like '%#[000000000#]%' {escape '#'}  then 'Canada'
when geo like '%#[PR%' {escape '#'}  then 'Province'
when geo like '%#[CAR%' {escape '#'}  then 'CensusAgriculturalRegion'
when geo like '%#[CD%'  {escape '#'}  then 'CensusDivision'
when geo like '%#[CCS%' {escape '#'}   then 'CensusConsolidatedSubdivision'
when geo like 'Northwest Territories%' or geo like 'Yukon%' or geo like 'Nunavut%' then 'Territory'
end),

-- GEO,
LEFT(GEO, CHARINDEX(' [', GEO) - 1) ,
REPLACE(CONCAT(Indicator,'_',IndicatorLevel,'_',[Unit of Measure]), ' ', '')

""", engine)






# =============================================================================
# # SUBSET DATA BASED ON GEO TYPE
# =============================================================================
Canada = df[df.Geo_Type=='Canada']

list = ['Province','Territory']
Province_Territory = df[df.Geo_Type.isin(list)]
del(list)

CensusAgriculturalRegion = df[df.Geo_Type=='CensusAgriculturalRegion']
CensusDivision = df[df.Geo_Type=='CensusDivision']
CensusConsolidatedSubdivision = df[df.Geo_Type=='CensusConsolidatedSubdivision']



# =============================================================================
# # PIVOT DATA
# =============================================================================

#hardcoded
test_hardcoded = CensusConsolidatedSubdivision.pivot(index='GEO1', columns='Parameter', values='SumValue')


# function
def MY_PIVOT(table) :
    """ Pivot a subset of census data, so we can create a correlogram later """
    new_table = table.pivot(index='GEO1', columns='Parameter', values='SumValue')
    return new_table

# pivot all subsets
Pvt_Canada= MY_PIVOT(Canada)

Pvt_Province_Territory= MY_PIVOT(Province_Territory)

Pvt_CensusAgriculturalRegion = MY_PIVOT(CensusAgriculturalRegion)
Pvt_CensusDivision = MY_PIVOT(CensusDivision)
Pvt_CensusConsolidatedSubdivision = MY_PIVOT(CensusConsolidatedSubdivision)



# are the two dataframes equal: hardcoded and generated by function? Quality check
# returns TRUE
test_hardcoded.equals(Pvt_CensusConsolidatedSubdivision)
# returns FALSE
test_hardcoded.equals(CensusDivision)

# del temp test dataset
del(test_hardcoded)





# =============================================================================
# CORRELATIONS
# =============================================================================

# create a test hardcoded corr matrix
test = Pvt_Province_Territory.corr()
test
test.style.background_gradient(cmap='coolwarm')


# create corr matrices via function
def MY_CORR(pivot_table):
    """ create a correlation matrix from a pivoted dataframe """
    corr_matrix = pivot_table.corr()
    return corr_matrix


Corr_Province_Territory = MY_CORR(Pvt_Province_Territory)
Corr_Province_Territory = MY_CORR(Pvt_Province_Territory)
Corr_CensusAgriculturalRegion = MY_CORR(Pvt_CensusAgriculturalRegion)
Corr_CensusDivision = MY_CORR(Pvt_CensusDivision)
Corr_CensusConsolidatedSubdivision = MY_CORR(Pvt_CensusConsolidatedSubdivision)


# QA check: are they the same?
test.equals(Corr_Province_Territory)

# delet temp dataset
del(test)



# =============================================================================
# SAMPE CORRELOGRAM - TEST
# =============================================================================
#https://seaborn.pydata.org/examples/many_pairwise_correlations.html

##from string import ascii_letters
#import numpy as np
#import seaborn as sns
#import matplotlib.pyplot as plt
#
#sns.set(style="white")
#
#
## Compute the correlation matrix
#corr = Pvt_Province_Territory.corr()
#
## Generate a mask for the upper triangle
#mask = np.zeros_like(corr, dtype=np.bool)
#mask[np.triu_indices_from(mask)] = True
#
## Set up the matplotlib figure
#f, ax = plt.subplots(figsize=(11, 9))
#
## Generate a custom diverging colormap
##cmap = sns.diverging_palette(220, 10, sep=20, as_cmap=True)
##cmap = sns.diverging_palette(220, 10, sep=20, as_cmap=True)
#
#cmap = sns.diverging_palette(240, 10, sep=200, as_cmap=True)
#
## Draw the heatmap with the mask and correct aspect ratio
#sns.heatmap(corr, mask=mask, cmap=cmap, center=0,
#            square=True, linewidths=.5, cbar_kws={"shrink": .5})
#
#ax.figure.savefig('file1.jpeg', orientation='landscape', papertype='ledger',pad_inches =0.001, bbox_inches='tight')
#
#ax.figure.savefig('file2.jpeg',  bbox_inches='tight')
# =============================================================================
# TEST ENDS
# =============================================================================



# =============================================================================
# FUNCTION CORRELOGRAM
# =============================================================================
def MY_CORRELOGRAM(pivot_table, exportfilename='File'):
    """ create a correlogram from a pivot table """
    #from string import ascii_letters
    import numpy as np
    import seaborn as sns
    import matplotlib.pyplot as plt

    sns.set(style="white")


    # Compute the correlation matrix
    corr = pivot_table.corr()

    # Generate a mask for the upper triangle
    mask = np.zeros_like(corr, dtype=np.bool)
    mask[np.triu_indices_from(mask)] = True

    # Set up the matplotlib figure
    f, ax = plt.subplots(figsize=(11, 9))

    # Generate a custom diverging colormap
    #cmap = sns.diverging_palette(220, 10, sep=20, as_cmap=True)
    #cmap = sns.diverging_palette(220, 10, sep=20, as_cmap=True)

    plt.title(('Correlations Part ' + exportfilename), fontsize=25)




    cmap = sns.diverging_palette(240, 10, sep=200, as_cmap=True)

    # Draw the heatmap with the mask and correct aspect ratio
    sns.heatmap(corr, mask=mask, cmap=cmap, center=0,
                square=True, linewidths=.5, cbar_kws={"shrink": .5})

    ax.figure.savefig((exportfilename + '.jpeg'),  bbox_inches='tight')






print("Pvt_Province_Territory")
MY_CORRELOGRAM(Pvt_Province_Territory, exportfilename='1 - Provinces & Territories')

print("Pvt_CensusAgriculturalRegion")
MY_CORRELOGRAM(Pvt_CensusAgriculturalRegion, exportfilename='2 - Census Agricultural Regions')

print("Pvt_CensusDivision")
MY_CORRELOGRAM(Pvt_CensusDivision, exportfilename='3 - Census Divisions')

print("Pvt_CensusConsolidatedSubdivision")
MY_CORRELOGRAM(Pvt_CensusConsolidatedSubdivision, exportfilename='4 - Census Consolidated Subdivisions')



end = time.time()
Time_Code_Ran_Seconds = end - start
Time_Code_Ran_Minutes_Decimal = Time_Code_Ran_Seconds / 60

print('Time the code ran in seconds is: ' + str(Time_Code_Ran_Seconds))
print('Time the code ran in minutes (decimal): ' + str(Time_Code_Ran_Minutes_Decimal))


# =============================================================================
# play a sound when done running the code
# on a GOA machine it's super quiet
# =============================================================================
import winsound
duration = 1000  # milliseconds
freq = 440  # Hz
winsound.Beep(freq, duration)
